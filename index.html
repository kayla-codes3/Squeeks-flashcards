<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flashcard Study Tool</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;
    
    const Plus = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    );

    const ChevronLeft = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    );

    const ChevronRight = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    );

    const Trash2 = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        <line x1="10" y1="11" x2="10" y2="17"></line>
        <line x1="14" y1="11" x2="14" y2="17"></line>
      </svg>
    );

    const Edit = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
      </svg>
    );

    const Folder = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
      </svg>
    );

    const File = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
        <polyline points="13 2 13 9 20 9"></polyline>
      </svg>
    );

    const ArrowLeft = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="19" y1="12" x2="5" y2="12"></line>
        <polyline points="12 19 5 12 12 5"></polyline>
      </svg>
    );

    function FlashcardApp() {
      const [folders, setFolders] = useState([
        {
          id: 'default',
          name: 'My First Folder',
          files: [
            {
              id: 'default-file',
              name: 'Browser & OS Basics',
              cards: [
                { id: '1', question: 'What is a Browser?', answer: "A browser is a program that lets you visit websites on the internet. It's your gateway to the online world!" },
                { id: '2', question: 'What are the 3 main browsers?', answer: 'Google Chrome, Microsoft Edge, and Apple Safari' },
                { id: '3', question: "What is Google's browser called?", answer: 'Google Chrome' },
                { id: '4', question: "What is Microsoft's browser called?", answer: 'Microsoft Edge' },
                { id: '5', question: "What is Apple's browser called?", answer: 'Safari' },
                { id: '6', question: 'What is an Operating System?', answer: 'An operating system is the main program that runs your computer or phone. It controls everything and lets all your apps work!' },
                { id: '7', question: 'What are the main computer operating systems?', answer: 'Mac OS (only on Macs) and Windows' },
                { id: '8', question: 'What are the main phone operating systems?', answer: 'iOS (only on iPhones) and Android' }
              ],
              archivedCards: []
            }
          ]
        }
      ]);
      
      const [archivedFolders, setArchivedFolders] = useState([]);
      const [archivedFiles, setArchivedFiles] = useState([]);
      const [showArchivedFolders, setShowArchivedFolders] = useState(false);
      const [showArchivedFiles, setShowArchivedFiles] = useState(false);
      const [currentView, setCurrentView] = useState('home');
      const [selectedFolderId, setSelectedFolderId] = useState(null);
      const [selectedFileId, setSelectedFileId] = useState(null);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [isFlipped, setIsFlipped] = useState(false);
      const [showAddForm, setShowAddForm] = useState(false);
      const [showEditForm, setShowEditForm] = useState(false);
      const [showBulkImport, setShowBulkImport] = useState(false);
      const [showArchived, setShowArchived] = useState(false);
      const [newQuestion, setNewQuestion] = useState('');
      const [newAnswer, setNewAnswer] = useState('');
      const [editingCardId, setEditingCardId] = useState(null);
      const [bulkText, setBulkText] = useState('');
      const [quizMode, setQuizMode] = useState(false);
      const [quizCards, setQuizCards] = useState([]);
      const [quizScore, setQuizScore] = useState(0);
      const [quizAnswered, setQuizAnswered] = useState(false);
      const [timeRemaining, setTimeRemaining] = useState(0);
      const [quizComplete, setQuizComplete] = useState(false);
      const [showTimePicker, setShowTimePicker] = useState(false);
      const [selectedHours, setSelectedHours] = useState(0);
      const [selectedMinutes, setSelectedMinutes] = useState(5);
      const [selectedSeconds, setSelectedSeconds] = useState(0);
      const [showFolderForm, setShowFolderForm] = useState(false);
      const [showFileForm, setShowFileForm] = useState(false);
      const [newFolderName, setNewFolderName] = useState('');
      const [newFileName, setNewFileName] = useState('');
      const [renamingId, setRenamingId] = useState(null);
      const [renamingType, setRenamingType] = useState(null);
      const [renameValue, setRenameValue] = useState('');

      const getCurrentCards = () => {
        if (!selectedFolderId || !selectedFileId) return [];
        const folder = folders.find(f => f.id === selectedFolderId);
        if (!folder) return [];
        const file = folder.files.find(f => f.id === selectedFileId);
        return file ? file.cards : [];
      };

      const updateCards = (newCards) => {
        setFolders(folders.map(folder => {
          if (folder.id === selectedFolderId) {
            return {
              ...folder,
              files: folder.files.map(file => {
                if (file.id === selectedFileId) {
                  return { ...file, cards: newCards };
                }
                return file;
              })
            };
          }
          return folder;
        }));
      };

      const getArchivedCards = () => {
        if (!selectedFolderId || !selectedFileId) return [];
        const folder = folders.find(f => f.id === selectedFolderId);
        if (!folder) return [];
        const file = folder.files.find(f => f.id === selectedFileId);
        return file ? file.archivedCards : [];
      };

      const updateArchivedCards = (newArchived) => {
        setFolders(folders.map(folder => {
          if (folder.id === selectedFolderId) {
            return {
              ...folder,
              files: folder.files.map(file => {
                if (file.id === selectedFileId) {
                  return { ...file, archivedCards: newArchived };
                }
                return file;
              })
            };
          }
          return folder;
        }));
      };

      const cards = getCurrentCards();
      const archivedCards = getArchivedCards();

      useEffect(() => {
        if (quizMode && timeRemaining > 0 && !quizComplete) {
          const timer = setTimeout(() => {
            setTimeRemaining(timeRemaining - 1);
          }, 1000);
          return () => clearTimeout(timer);
        } else if (quizMode && timeRemaining === 0 && !quizComplete) {
          handleQuizEnd();
        }
      }, [quizMode, timeRemaining, quizComplete]);

      const createFolder = () => {
        if (newFolderName.trim()) {
          const newFolder = {
            id: Date.now().toString(),
            name: newFolderName,
            files: []
          };
          setFolders([...folders, newFolder]);
          setNewFolderName('');
          setShowFolderForm(false);
        }
      };

      const createFile = () => {
        if (newFileName.trim() && selectedFolderId) {
          setFolders(folders.map(folder => {
            if (folder.id === selectedFolderId) {
              return {
                ...folder,
                files: [...folder.files, {
                  id: Date.now().toString(),
                  name: newFileName,
                  cards: [],
                  archivedCards: []
                }]
              };
            }
            return folder;
          }));
          setNewFileName('');
          setShowFileForm(false);
        }
      };

      const startRename = (id, type, currentName) => {
        setRenamingId(id);
        setRenamingType(type);
        setRenameValue(currentName);
      };

      const saveRename = () => {
        if (renameValue.trim()) {
          if (renamingType === 'folder') {
            setFolders(folders.map(f => f.id === renamingId ? { ...f, name: renameValue } : f));
          } else if (renamingType === 'file') {
            setFolders(folders.map(folder => {
              if (folder.id === selectedFolderId) {
                return {
                  ...folder,
                  files: folder.files.map(file => 
                    file.id === renamingId ? { ...file, name: renameValue } : file
                  )
                };
              }
              return folder;
            }));
          }
        }
        setRenamingId(null);
        setRenamingType(null);
        setRenameValue('');
      };

      const deleteFolder = (folderId) => {
        if (window.confirm('Archive this folder and all its files? You can recover it within 24 hours.')) {
          const folderToArchive = folders.find(f => f.id === folderId);
          setArchivedFolders([...archivedFolders, { ...folderToArchive, deletedAt: Date.now() }]);
          setFolders(folders.filter(f => f.id !== folderId));
        }
      };

      const deleteFile = (fileId) => {
        if (window.confirm('Archive this file and all its cards? You can recover it within 24 hours.')) {
          const folder = folders.find(f => f.id === selectedFolderId);
          const fileToArchive = folder.files.find(f => f.id === fileId);
          setArchivedFiles([...archivedFiles, { ...fileToArchive, folderId: selectedFolderId, deletedAt: Date.now() }]);
          setFolders(folders.map(folder => {
            if (folder.id === selectedFolderId) {
              return {
                ...folder,
                files: folder.files.filter(f => f.id !== fileId)
              };
            }
            return folder;
          }));
          if (selectedFileId === fileId) {
            setCurrentView('folder');
            setSelectedFileId(null);
          }
        }
      };

      const recoverFolder = (index) => {
        const validFolders = getValidArchivedFolders();
        const folderToRecover = validFolders[index];
        setFolders([...folders, folderToRecover]);
        setArchivedFolders(archivedFolders.filter(f => f !== folderToRecover));
      };

      const recoverFile = (index) => {
        const validFiles = getValidArchivedFiles();
        const fileToRecover = validFiles[index];
        setFolders(folders.map(folder => {
          if (folder.id === fileToRecover.folderId) {
            return {
              ...folder,
              files: [...folder.files, { ...fileToRecover, deletedAt: undefined, folderId: undefined }]
            };
          }
          return folder;
        }));
        setArchivedFiles(archivedFiles.filter(f => f !== fileToRecover));
      };

      const getValidArchivedFolders = () => {
        const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
        return archivedFolders.filter(folder => folder.deletedAt > twentyFourHoursAgo);
      };

      const getValidArchivedFiles = () => {
        const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
        return archivedFiles.filter(file => file.deletedAt > twentyFourHoursAgo);
      };

      const showQuizTimePicker = () => {
        setShowTimePicker(true);
        setShowArchived(false);
      };

      const startQuiz = () => {
        const shuffled = [...cards].sort(() => Math.random() - 0.5);
        setQuizCards(shuffled);
        setQuizMode(true);
        setQuizScore(0);
        setCurrentIndex(0);
        setIsFlipped(false);
        setQuizAnswered(false);
        setQuizComplete(false);
        setShowTimePicker(false);
        const totalSeconds = (selectedHours * 3600) + (selectedMinutes * 60) + selectedSeconds;
        setTimeRemaining(totalSeconds);
      };

      const exitQuiz = () => {
        setQuizMode(false);
        setQuizComplete(false);
        setCurrentIndex(0);
        setIsFlipped(false);
        setQuizAnswered(false);
        setShowTimePicker(false);
      };

      const handleQuizAnswer = (correct) => {
        if (correct === 'full') {
          setQuizScore(quizScore + 1);
        } else if (correct === 'partial') {
          setQuizScore(quizScore + 0.5);
        }
        
        if (currentIndex < quizCards.length - 1) {
          setCurrentIndex(currentIndex + 1);
          setIsFlipped(false);
          setQuizAnswered(false);
        } else {
          handleQuizEnd();
        }
      };

      const handleQuizEnd = () => {
        setQuizComplete(true);
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const handleFlip = () => {
        setIsFlipped(!isFlipped);
      };

      const handleNext = () => {
        if (cards.length > 1) {
          setIsFlipped(false);
          setCurrentIndex((prev) => (prev + 1) % cards.length);
        }
      };

      const handlePrevious = () => {
        if (cards.length > 1) {
          setIsFlipped(false);
          setCurrentIndex((prev) => (prev - 1 + cards.length) % cards.length);
        }
      };

      const handleAddCard = () => {
        if (newQuestion.trim() && newAnswer.trim()) {
          const newCard = {
            id: Date.now().toString(),
            question: newQuestion,
            answer: newAnswer
          };
          updateCards([...cards, newCard]);
          setNewQuestion('');
          setNewAnswer('');
          setShowAddForm(false);
        }
      };

      const startEditCard = () => {
        const card = cards[currentIndex];
        setEditingCardId(card.id);
        setNewQuestion(card.question);
        setNewAnswer(card.answer);
        setShowEditForm(true);
      };

      const handleEditCard = () => {
        if (newQuestion.trim() && newAnswer.trim()) {
          updateCards(cards.map(card => 
            card.id === editingCardId 
              ? { ...card, question: newQuestion, answer: newAnswer }
              : card
          ));
          setNewQuestion('');
          setNewAnswer('');
          setEditingCardId(null);
          setShowEditForm(false);
        }
      };

      const handleDeleteCard = () => {
        if (cards.length > 0) {
          const deletedCard = cards[currentIndex];
          const newCards = cards.filter((_, index) => index !== currentIndex);
          updateCards(newCards);
          updateArchivedCards([...archivedCards, { ...deletedCard, deletedAt: Date.now() }]);
          if (newCards.length > 0) {
            setCurrentIndex(Math.min(currentIndex, newCards.length - 1));
          } else {
            setCurrentIndex(0);
          }
          setIsFlipped(false);
        }
      };

      const handleDeleteAll = () => {
        if (window.confirm('Are you sure you want to delete all flashcards? They will be archived for 24 hours.')) {
          const timestamp = Date.now();
          const archived = cards.map(card => ({ ...card, deletedAt: timestamp }));
          updateArchivedCards([...archivedCards, ...archived]);
          updateCards([]);
          setCurrentIndex(0);
          setIsFlipped(false);
        }
      };

      const handleBulkImport = () => {
        const lines = bulkText.split('\n');
        const newCards = [];
        let currentQuestion = '';
        let currentAnswer = '';
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          if (line.startsWith('Q:')) {
            currentQuestion = line.substring(2).trim();
          } else if (line.startsWith('A:')) {
            currentAnswer = line.substring(2).trim();
            if (currentQuestion && currentAnswer) {
              newCards.push({ 
                id: Date.now().toString() + '-' + i,
                question: currentQuestion, 
                answer: currentAnswer 
              });
              currentQuestion = '';
              currentAnswer = '';
            }
          }
        }
        
        if (newCards.length > 0) {
          updateCards([...cards, ...newCards]);
          setBulkText('');
          setShowBulkImport(false);
        } else {
          alert('No valid cards found. Make sure to use the format:\nQ: Your question\nA: Your answer');
        }
      };

      const handleRecover = (index) => {
        const validCards = getValidArchivedCards();
        const cardToRecover = validCards[index];
        updateCards([...cards, { ...cardToRecover, id: Date.now().toString() }]);
        updateArchivedCards(archivedCards.filter(card => card !== cardToRecover));
      };

      const getValidArchivedCards = () => {
        const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
        return archivedCards.filter(card => card.deletedAt > twentyFourHoursAgo);
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8 relative overflow-hidden">
          <div className="max-w-4xl mx-auto relative z-10">
            <h1 className="text-4xl font-bold text-center text-indigo-900 mb-4">
              Flashcard Study Tool
            </h1>

            {currentView !== 'home' && (
              <button
                onClick={() => {
                  if (currentView === 'file') {
                    setCurrentView('folder');
                    setSelectedFileId(null);
                    setShowArchivedFiles(false);
                  } else if (currentView === 'folder') {
                    setCurrentView('home');
                    setSelectedFolderId(null);
                    setShowArchivedFolders(false);
                  }
                }}
                className="mb-4 flex items-center gap-2 px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors"
              >
                <ArrowLeft size={20} />
                Back
              </button>
            )}

            {currentView === 'home' && (
              <div>
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-2xl font-bold text-gray-800">My Folders</h2>
                  <div className="flex gap-3">
                    <button
                      onClick={() => setShowArchivedFolders(!showArchivedFolders)}
                      className="flex items-center gap-2 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors"
                    >
                      View Archived ({getValidArchivedFolders().length})
                    </button>
                    <button
                      onClick={() => setShowFolderForm(true)}
                      className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      <Plus size={20} />
                      New Folder
                    </button>
                  </div>
                </div>

                {showArchivedFolders && (
                  <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                    <h3 className="text-xl font-semibold text-gray-800 mb-4">
                      Archived Folders (Last 24 Hours)
                    </h3>
                    {getValidArchivedFolders().length === 0 ? (
                      <p className="text-gray-500 text-center">No archived folders</p>
                    ) : (
                      <div className="space-y-3">
                        {getValidArchivedFolders().map((folder, index) => (
                          <div key={index} className="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                            <div className="flex-1">
                              <div className="font-medium text-gray-800">{folder.name}</div>
                              <div className="text-sm text-gray-600">{folder.files.length} file(s)</div>
                            </div>
                            <button
                              onClick={() => recoverFolder(index)}
                              className="ml-4 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors text-sm"
                            >
                              Recover
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {showFolderForm && (
                  <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                    <h3 className="text-xl font-semibold mb-4">Create New Folder</h3>
                    <input
                      type="text"
                      value={newFolderName}
                      onChange={(e) => setNewFolderName(e.target.value)}
                      placeholder="Folder name..."
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg mb-4"
                    />
                    <div className="flex gap-3">
                      <button onClick={createFolder} className="flex-1 px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">
                        Create
                      </button>
                      <button onClick={() => { setShowFolderForm(false); setNewFolderName(''); }} className="flex-1 px-6 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">
                        Cancel
                      </button>
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {folders.map(folder => (
                    <div key={folder.id} className="bg-white rounded-xl shadow-lg p-6 hover:shadow-xl transition-shadow">
                      {renamingId === folder.id && renamingType === 'folder' ? (
                        <div className="flex gap-2">
                          <input
                            type="text"
                            value={renameValue}
                            onChange={(e) => setRenameValue(e.target.value)}
                            className="flex-1 px-3 py-1 border border-gray-300 rounded"
                            autoFocus
                          />
                          <button onClick={saveRename} className="px-3 py-1 bg-green-500 text-white rounded">Save</button>
                          <button onClick={() => setRenamingId(null)} className="px-3 py-1 bg-gray-300 rounded">Cancel</button>
                        </div>
                      ) : (
                        <div>
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-3">
                              <Folder size={32} />
                              <h3 className="text-xl font-semibold text-gray-800">{folder.name}</h3>
                            </div>
                            <div className="flex gap-2">
                              <button
                                onClick={() => startRename(folder.id, 'folder', folder.name)}
                                className="p-2 text-gray-600 hover:bg-gray-100 rounded"
                              >
                                <Edit size={18} />
                              </button>
                              <button
                                onClick={() => deleteFolder(folder.id)}
                                className="p-2 text-red-600 hover:bg-red-50 rounded"
                              >
                                <Trash2 size={18} />
                              </button>
                            </div>
                          </div>
                          <p className="text-gray-600 mb-4">{folder.files.length} file(s)</p>
                          <button
                            onClick={() => {
                              setSelectedFolderId(folder.id);
                              setCurrentView('folder');
                              setShowArchivedFolders(false);
                            }}
                            className="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                          >
                            Open Folder
                          </button>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {currentView === 'folder' && selectedFolderId && (
              <div>
                <div className="flex justify-between items-center mb-6">
                  <h2 className="text-2xl font-bold text-gray-800">
                    {folders.find(f => f.id === selectedFolderId)?.name}
                  </h2>
                  <div className="flex gap-3">
                    <button
                      onClick={() => setShowArchivedFiles(!showArchivedFiles)}
                      className="flex items-center gap-2 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors"
                    >
                      View Archived ({getValidArchivedFiles
